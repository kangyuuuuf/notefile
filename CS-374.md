# CS 374

This course introduces three distinct fields of computer science research: **computational complexity**, **algorithms**, and **limits of computation**.

## Week 1

#### Definition

1. An algorithm is a step-by-step way to solve a problem. 

2. A problem is some questions that we’d like answered given some input. It should be a decision problem of the form ”Does a given input fulfill property X.” 
3. A Language is a set of strings. Given an alphabet, Σ a language is a subset of Σ$^*$. A language is a formal realization of this problem. 

#### Strings

An alphabet is a **finite** set of symbols.

A string over $\Sigma$ is a finite sequence of symbols over $\Sigma$. For integer $n \geq 0, \Sigma^n$ is set of all strings over $\Sigma$ of length $n$. $\Sigma^*$ is set of all strings over $\Sigma$.

##### Emptiness

$\epsilon$ is a string containing no symbols. It is not a set.  $\empty$ is a string of a empty set. Differ than, {$\epsilon$} or {$\empty$}

##### Concatenation and properties

We denote $xy$ or $x \cdot y$, **Concatenation** is defined recursively:

- $xy=y$ if $x = \epsilon$
- $xy = a(wy)$ if $x = aw$

Concatenation is associative: $(uv)w = u(vw)$, hence write $uvw \equiv(uv)w = u(vw)$

**Not** commutative: $uv$ not necessarily equal to $vu$.

The identity element is the empty string $\epsilon$:
$$
\epsilon u = u \epsilon  = u.
$$

#### Substrings, prefixes, Suffixes

$v$ is substring of $w$ $\iff$ there exist strings $x,y$ such that $w= xvy$.

- If $x = \epsilon$ then $v$ is a prefix of $w$
- If $y = \epsilon$ then $v$ is a suffix of $w$

If $w$ is a string, then $w$ n is defined inductively as follows:

- $w^n = \epsilon$ if $n =0$
- $w^n = ww^{n-1}$ if $n > 0$

#### Subsequence

A subsequence of a string w[1...n] is either a subsequence of w[2...n] or w[1] followed by a subsequence of w[2...n].

#### Language

  A language L is a set of strings over Σ. In other words L ⊆ Σ$^*$. In other words L ⊆ Σ$^*$. Standard set operations apply to languages.

<img src="CS-374.assets/image-20220823143232946.png" alt="image-20220823143232946" style="zoom:50%;" />

Given two sets X and Y of strings (over some common alphabet Σ) the concatenation of X and Y is
$$
XY =\{xy \mid x \in X, y\in Y\}
$$
Note that $\Sigma^+=\cup_{n\ge1}\Sigma^n$.

 

#### Inductive proofs on Strings

The reverse $w^R$ of a string $w$ is defined as follows:

- $w^R = \epsilon$ if $w = \epsilon$
- $w^R = x^Ra$ if $w = ax$ for some $a \in \Sigma$ and string $x$

#### String Induction 

Here is the our current lemma

<img src="CS-374.assets/image-20220824091918926.png" alt="image-20220824091918926" style="zoom:50%;" />

Here is the question;

<img src="CS-374.assets/image-20220824091800539.png" alt="image-20220824091800539" style="zoom:50%;" />

##### Question 1:

Induction Hypothesis: Let w be any string. Assume there is x such that $|x| < |w|$ such that $|x| = |x^R|$

Base case: When $w = \epsilon$, we have $|w|= 0$. Also, $w^R = \epsilon$, then $|w^R| = 0 = |w|$.

Inductive step: Assume $w= ax$, for some string x and for some symbol a. We have
$$
|w| = |a\cdot x| = |a| + |x| \\
|w^R| = |x^R \cdot a| =|x^R|+ |a|
$$
Since we already know that $|x^R| = |x|$, we have
$$
|w^R| = |x^R \cdot a| =|x^R|+ |a| = |a| + |x| = |w|
$$
Therefore, we conclude that $|w| = |w^R|$.$\blacksquare$

##### Question 2:

Induction Hypothesis: Let w and z be any string. 

Base case: When $w=\epsilon$, we have 
$$
(w\cdot z)^R = (\epsilon \cdot z)^R = z^R = z^R \cdot \epsilon^R = z^R \cdot w^R
$$
Inductive step: Assume for some string $x$ and for some symbol a, $w = ax$ and $(x\cdot z)^R = z^R\cdot x^R$.

Then, we have
$$
(w\cdot z)^R = (ax \cdot z)^R = [a(x\cdot z)]^R
$$
Treat $x\cdot z$ as one string, we have
$$
(w\cdot z)^R =[a(x\cdot z)]^R = (x\cdot z)^R \cdot a = z^R \cdot x^R \cdot a = z^R \cdot (x^R \cdot a) = z^R \cdot w^R
$$
Then, we can conclude $(w\cdot z)^R = z^R \cdot w^R$.$\blacksquare$

##### Quesiton 3:

Induction Hypothesis: Let w be any string. Assume for some string x and some symbol a, w = ax that $(x^R)^R = x$.

Base case: When $w = \epsilon$, we have $w^R = \epsilon = \epsilon^R=(w^R)^R $.

Inductive step: Assume for some string x and some symbol a, w = ax that $(x^R)^R = x$.

We have
$$
(w^R)^R = (x^R\cdot a)^R = a^R \cdot (x^R)^R = a \cdot x = w
$$
Then, we can conclude $w = (w^R)^R$.$\blacksquare$

<img src="CS-374.assets/image-20220824103409844.png" alt="image-20220824103409844" style="zoom:50%;" />

##### Question 4

$$
\#(a,w) = \left\{
\begin{array}{ll}
        0 & if \ w = \epsilon \\
        1 + \#(a,x) & if  \ w = bx \ \text{and} \ a = b \\
        \#(a,x)	& if  \ w = bx \ \text{and} \ a \neq b \\
    \end{array}
\right.
$$

### Regular Language

**Kleene’s Theorem**	A language is regular if and only if it can be obtained from finite languages by applying the three operations:

- Union
- Concatenation
- Repetition

a finite number of times.

##### Base Case

$\empty$ , $\{\epsilon\}$, and $\{a\}$is a regular language

##### Inductive step

If $L_1$, $L_2$ are  regular, then $L_1 \cup L_2$ is regular

If $L_1$, $L_2$ are  regular, then $L_1 L_2$ is regular

If $L$ is regular, then $L^* = \cup_{n \ge0} L^n$ is regular. The $^*$ operator name is **Kleene star**.

If $L$ is regular, then so is $\overline L = \Sigma^* \backslash L$

Regular languages are **closed** under **operations** of union, concatenation, and Kleene star.

Any language generated by a finite sequence of such operations is regular.

#### Regular Expression

Inductive case: If $r_1$ and $r_2$ are regular expressions denoting languages $R_1$ and $R_2$ respectively then,

- $(r_1+r_2)$ denotes the language $R_1 \cup R_2$
- $(r_1 \cdot r_2) = r_1 \cdot r_2 = (r_1r_2) $ denotes the language $R_1R_2$
- $(r_1)^*$ denotes the language $R^*_1$

##  Week 2

### DFAs

DFAs also called Finite State Machines, which have programs with fixed memory.

#### Graphical Representation

Directed graph with nodes representing states and edges representing transitions labeled by symbols in $\Sigma$.

For each state(vertex) $q$ and symbol $a\in \Sigma$ there is exactly one outgoing edge labeled by $a$.

Start state has a pointer

Some states with double circles labeled as accepting/final states.

#### Definition

A DFA $M$ accepts a string $w$ $iff$ the unique walk starting at the start state and spelling out $w$ ends in an accepting state.

##### Formal definition

A determiniistic finite automata(DFA) $M = (Q,\Sigma, \delta, s, A)$ is a five-tuple where 

- $Q$ is a finite set whose elements are called states.
- $\Sigma$ is a finite set called input alphabet
- $\delta : Q \times \Sigma \rarr Q $   is the transition function
- $s \in Q$ is the start state
- $A \sube Q$ is the set of accepting/final states

#### Constructing DFAs

The language $L(M)$ accepted by a DFA $M = (Q,\Sigma, \delta, s, A)$  is 
$$
\{w\in \Sigma^* | \delta^*(s,w)\in A\}.
$$
<img src="CS-374.assets/image-20220831122039316.png" alt="image-20220831122039316" style="zoom:50%;" />

Languages accepted by DFAs are closed under complement.

### NFAs

#### Non-determinism in computing

![image-20220901125613566](CS-374.assets/image-20220901125613566.png)

**Informal definition:** An NFA $N$ accepts s string $w$ $\iff$ some accepting state is reached by $N$ from the state on input $w$

For NFAs transition function, we have

$\delta: Q \times\Sigma \cup\{\epsilon\} \rarr P(Q)$ is the transition function of NFA, where $P(Q)$ is the power set of $Q$.

<img src="CS-374.assets/image-20220901131856814.png" alt="image-20220901131856814" style="zoom:50%;" />

###  RegExp-DFA-NFA Equivalence

Languages accepted by DFAs, NFAs, and regular expressions arethe same.

- DFAs are special cases of NFAs (easy)
- NFAs accept regular expressions (seen)
- DFAs accept languages accepted by NFAs (shortly)
- Regular expressions for languages accepted by DFAs (shown previously)

<img src="CS-374.assets/image-20220906125048066.png" alt="image-20220906125048066" style="zoom:50%;" />

#### Regular Expression to NFA

Thompson’s algorithm: Given two NFAs $s$ and $t$,

<img src="CS-374.assets/image-20220906125218807.png" alt="image-20220906125218807" style="zoom:50%;" />

#### Conversion of NFA to DFA

For every NFA $N$ there is a DFA $M$ such that $L(M ) = L(N )$.

- DFA knows only its current state.
- The state is the memory.
- To design a DFA, answer the question: What minimal info needed to solve problem.

NFA $N = (Q ,Σ,s ,δ,A).$ We create a DFA $D = (Q',Σ,δ',s',A')$ as follows:

### Proving non-regularity: Methods

#### Three methods

##### **Pumping lemma**

It is sometimes an easier proof technique to apply, but not as general as the fooling set technique.

##### **Closure**

Using existing non-regular language and regular languages to prove that some new languages is non-regular.

##### **Fooling sets**

A method of distinguishing suffixes. To prove that some new language is non-regular.



Number of regular languages is **countably infinite**; Number of languages is **uncountably infinite**

Example: $L = \{0^n1^n | n \ge 0\}$ is not regular. 

**Intuition:** any program to recognize L seems to require counting number of zero in input which cannot be done with fixed memory.

Proof by contradiction

Let L be a language. Define: strings $x$ and $y$ are distinguishable $\iff$ $\exist z, x z\in L \text{ and } y z\notin L$

Let $M = (Q,\epsilon, \delta, s, A)$. Notation $\triangledown x$ for a string $x$ is the state $\delta^* (s,x)$

**Lemma 1**  		if x and y are distinguishable for $L(M)$ then  $\triangledown x \neq \triangledown y$.

**Definition	**	Two states $p,q \in Q$ are equivalent if for all string $w \in \Sigma^*$ , we have that 
$$
\delta^*(p,w) \in A \iff  \delta^*(q,w) \in A
$$


**Definition**		Two states $p,q \in Q$ are distinguishable if there exists a sring $w \in \Sigma^*$ , such that 
$$
\delta^*(p,w) \in A \text{ and }  \delta^*(q,w) \notin A \\ \text{or}\\
\delta^*(p,w) \notin A \text{ and }  \delta^*(q,w) \in A
$$

#### Fooling Sets

##### Definition

For a language $L$ over $\Sigma$ a set of string $F$ (Could be infinite) is a fooling set or distinguishing set for $L$ if every two distinct strings $x,y \in F$ are distinguishable.

**Theorem**	Suppose $F$ is a fooling set for L. If $F$ is finite then there is no DFA $M$ that accepts $L$ with less than $|F|$ states.

 **Corollary**	If $L$ has an infinite fooling set $F$ then $L$ is not regular.

##### Closure Properties

We can use contradiction to prove non-regularity via closure properties. Here is a example:

$H = \{\text{bit strings with equal number of 0s and 1s}\}$

$H' = \{0^k1^k | k \ge 0\}$

Suppose $H$ is regular. Then since $L(0^*1^*)$ is regular, and regular languages are closed under intersection, $H'$ also would be regular. 
$$
H' = H \cap L(0^*1^*)
$$

But we know $H'$ is not regular, a contradiction. Therefore, $H$ is non-regular. 

**Example**: Prove: $L = \{ww^R|w\in \{0,1\}^*\}$ is non-regular

![image-20220914153526613](CS-374.assets/image-20220914153526613.png)

### Context-free Language and Grammars

Regular languages could be constructed using a finite number of 

- Unnoins
- Concatenations
- Repetitions

With context-free languages we have a much more powerful tool: Subsitution.

#### Formal Definition of CFGS

A CFG is a quadruple $G=(V,T,P,S)$ where is variables, terminals, productions, start var.

- $V$ is a finite set of **non-terminal (variable) symbols**

- $T$ is a finite set of **terminal symbols**(alphabet)

- $P$ is a finite set of **productions**, each of the form

  $A \rarr \alpha$ where $A \in V$ and $\alpha$ is a string in $(V\cup T)^*$ Formally, $P \sub V \times (V \cup T)^*$

- $S \in V$ is a start symbol

#### “Derives” relation

Let $G = (V,T,P,S)$ be a CFG. For strings $a_1,a_2 \in (V \cup T)^*$ we say $a_1$ **derives** $a_2$ denoted by $a_1 \leadsto_G a_2$  if there exist string $\beta,\gamma, \delta$ in $(V \cup T)^*$ such that

- $a_1 = \beta A \delta$
- $a_2$ = $\beta \gamma \delta$
- $A \rarr \gamma$ is in $P$

##### Definition

For integer $k \ge 0$, $a_1 \leadsto^k a_2$ inductive defined:

- $a_1 \leadsto^0 a_2$ if $a_1 = a_2$
- $a_1 \leadsto^k a_2$ if $a_1 \leadsto \beta_2 $ and $\beta_1 \leadsto^{k-1} a_2$.
- **Alternative definition:** $a_1 \leadsto ^k a_2$ if $a_1 \leadsto^{k-1} \beta_1$ and $\beta_1 \leadsto a_2$

$\leadsto^*$ is the reflexive and transitive closure of $\leadsto$.

$a_1 \leadsto^k a_2$ if $a_1 \leadsto^k a_2 $ for some $k$

#### Context Free Languages

The language generated by CFG $G = (V,T,P,S)$ is denoted by $L(G)$ where $L(G) = \{w\in T^*| S \leadsto^* w\} $

A language $L$ is context-free if it is generated by context-free grammar. That is, there is a CFG G such that $L = L (G)$

##### Lemma

For a regular language $L$, there us a context-free grammar(CFG) that generates it.

### Push-down automata

A non-deterministic push_down automata $P=(Q,\Sigma,\Gamma, \delta,s,A)$ is a six tuple where

- $Q$ is a finite set whose elements are called states,
- $\Sigma$ is a finite set called the input alphabet,
- $\Gamma$ is a finite set called the stack alphabet
- $\delta: Q \times \Sigma \cup \{\epsilon\} \times \Gamma \cup\{\epsilon\} \rarr P(Q \times (\Gamma \cup \{\epsilon\}))$ is the transition function
- $s$ is the start state
- $A$ is the set of accepting states.
