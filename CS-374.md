# CS 374

This course introduces three distinct fields of computer science research: **computational complexity**, **algorithms**, and **limits of computation**.

## Week 1

#### Definition

1. An algorithm is a step-by-step way to solve a problem. 

2. A problem is some questions that we’d like answered given some input. It should be a decision problem of the form ”Does a given input fulfill property X.” 
3. A Language is a set of strings. Given an alphabet, Σ a language is a subset of Σ$^*$. A language is a formal realization of this problem. 

#### Strings

An alphabet is a **finite** set of symbols.

A string over $\Sigma$ is a finite sequence of symbols over $\Sigma$. For integer $n \geq 0, \Sigma^n$ is set of all strings over $\Sigma$ of length $n$. $\Sigma^*$ is set of all strings over $\Sigma$.

##### Emptiness

$\epsilon$ is a string containing no symbols. It is not a set.  $\empty$ is a string of a empty set. Differ than, {$\epsilon$} or {$\empty$}

##### Concatenation and properties

We denote $xy$ or $x \cdot y$, **Concatenation** is defined recursively:

- $xy=y$ if $x = \epsilon$
- $xy = a(wy)$ if $x = aw$

Concatenation is associative: $(uv)w = u(vw)$, hence write $uvw \equiv(uv)w = u(vw)$

**Not** commutative: $uv$ not necessarily equal to $vu$.

The identity element is the empty string $\epsilon$:
$$
\epsilon u = u \epsilon  = u.
$$

#### Substrings, prefixes, Suffixes

$v$ is substring of $w$ $\iff$ there exist strings $x,y$ such that $w= xvy$.

- If $x = \epsilon$ then $v$ is a prefix of $w$
- If $y = \epsilon$ then $v$ is a suffix of $w$

If $w$ is a string, then $w$ n is defined inductively as follows:

- $w^n = \epsilon$ if $n =0$
- $w^n = ww^{n-1}$ if $n > 0$

#### Subsequence

A subsequence of a string w[1...n] is either a subsequence of w[2...n] or w[1] followed by a subsequence of w[2...n].

#### Language

  A language L is a set of strings over Σ. In other words L ⊆ Σ$^*$. In other words L ⊆ Σ$^*$. Standard set operations apply to languages.

<img src="CS-374.assets/image-20220823143232946.png" alt="image-20220823143232946" style="zoom:50%;" />

Given two sets X and Y of strings (over some common alphabet Σ) the concatenation of X and Y is
$$
XY =\{xy \mid x \in X, y\in Y\}
$$
Note that $\Sigma^+=\cup_{n\ge1}\Sigma^n$.

 

#### Inductive proofs on Strings

The reverse $w^R$ of a string $w$ is defined as follows:

- $w^R = \epsilon$ if $w = \epsilon$
- $w^R = x^Ra$ if $w = ax$ for some $a \in \Sigma$ and string $x$

#### String Induction 

Here is the our current lemma

<img src="CS-374.assets/image-20220824091918926.png" alt="image-20220824091918926" style="zoom:50%;" />

Here is the question;

<img src="CS-374.assets/image-20220824091800539.png" alt="image-20220824091800539" style="zoom:50%;" />

##### Question 1:

Induction Hypothesis: Let w be any string. Assume there is x such that $|x| < |w|$ such that $|x| = |x^R|$

Base case: When $w = \epsilon$, we have $|w|= 0$. Also, $w^R = \epsilon$, then $|w^R| = 0 = |w|$.

Inductive step: Assume $w= ax$, for some string x and for some symbol a. We have
$$
|w| = |a\cdot x| = |a| + |x| \\
|w^R| = |x^R \cdot a| =|x^R|+ |a|
$$
Since we already know that $|x^R| = |x|$, we have
$$
|w^R| = |x^R \cdot a| =|x^R|+ |a| = |a| + |x| = |w|
$$
Therefore, we conclude that $|w| = |w^R|$.$\blacksquare$

##### Question 2:

Induction Hypothesis: Let w and z be any string. 

Base case: When $w=\epsilon$, we have 
$$
(w\cdot z)^R = (\epsilon \cdot z)^R = z^R = z^R \cdot \epsilon^R = z^R \cdot w^R
$$
Inductive step: Assume for some string $x$ and for some symbol a, $w = ax$ and $(x\cdot z)^R = z^R\cdot x^R$.

Then, we have
$$
(w\cdot z)^R = (ax \cdot z)^R = [a(x\cdot z)]^R
$$
Treat $x\cdot z$ as one string, we have
$$
(w\cdot z)^R =[a(x\cdot z)]^R = (x\cdot z)^R \cdot a = z^R \cdot x^R \cdot a = z^R \cdot (x^R \cdot a) = z^R \cdot w^R
$$
Then, we can conclude $(w\cdot z)^R = z^R \cdot w^R$.$\blacksquare$

##### Quesiton 3:

Induction Hypothesis: Let w be any string. Assume for some string x and some symbol a, w = ax that $(x^R)^R = x$.

Base case: When $w = \epsilon$, we have $w^R = \epsilon = \epsilon^R=(w^R)^R $.

Inductive step: Assume for some string x and some symbol a, w = ax that $(x^R)^R = x$.

We have
$$
(w^R)^R = (x^R\cdot a)^R = a^R \cdot (x^R)^R = a \cdot x = w
$$
Then, we can conclude $w = (w^R)^R$.$\blacksquare$

<img src="CS-374.assets/image-20220824103409844.png" alt="image-20220824103409844" style="zoom:50%;" />

##### Question 4

$$
\#(a,w) = \left\{
\begin{array}{ll}
        0 & if \ w = \epsilon \\
        1 + \#(a,x) & if  \ w = bx \ \text{and} \ a = b \\
        \#(a,x)	& if  \ w = bx \ \text{and} \ a \neq b \\
    \end{array}
\right.
$$

### Regular Language

**Kleene’s Theorem**	A language is regular if and only if it can be obtained from finite languages by applying the three operations:

- Union
- Concatenation
- Repetition

a finite number of times.

##### Base Case

$\empty$ , $\{\epsilon\}$, and $\{a\}$is a regular language

##### Inductive step

If $L_1$, $L_2$ are  regular, then $L_1 \cup L_2$ is regular

If $L_1$, $L_2$ are  regular, then $L_1 L_2$ is regular

If $L$ is regular, then $L^* = \cup_{n \ge0} L^n$ is regular. The $^*$ operator name is **Kleene star**.

If $L$ is regular, then so is $\overline L = \Sigma^* \backslash L$

Regular languages are **closed** under **operations** of union, concatenation, and Kleene star.

Any language generated by a finite sequence of such operations is regular.

#### Regular Expression

Induective case: If $r_1$ and $r_2$ are regular expressions denoting languages $R_1$ and $R_2$ respectively then,

- $(r_1+r_2)$ denotes then language $R_1 \cup R_2$
- $(r_1 \cdot r_2) = r_1 \cdot r_2 = (r_1r_2) $ denotes the language $R_1R_2$
- $(r_1)^*$ denotes the language $R^*_1$

 
