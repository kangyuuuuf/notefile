# CS 445 - Computational Photography

## linear filtering

The most widely used type of neighborhood operator is a linear filter, where an output pixel‚Äôs value is a weighted sum of pixel values within a small neighborhood N
$$
g(i,j) = \sum_{k,l} f(i+k,j+l)h(k,l)
$$
The entries in the weight kernel or mask h(k, l) are often called the filter coefficients. The correlation operator can be notated as
$$
g =  f \otimes h
$$
A common variant on this formula is
$$
g(i,j) = \sum_{k,l} f(i-k,j-l)h(k,l)
$$
where the sign of the offsets in f has been reversed, This is called the convolution operator
$$
g = f* h
$$
Both correlation and convolution are linear shift-invariant (LSI) operators, which obey both the superposition principle,
$$
h \circ(f_0+f_1) = h \circ f_0+ h \circ f_1
$$
and the shift invariance principle,
$$
g(i,j) = f(i+k,j+l) \iff (h \circ g) (i,j) =(h \circ f)(i+k,j+l)
$$
The correlation will produce a result that is smaller than the original image. There are some ways to "compensate" the missing pixels:

- zero: set all pixels outside the source image to 0 (a good choice for alpha-matted cutout images);
- constant (border color): set all pixels outside the source image to a specified border value; 
- clamp (replicate or clamp to edge): repeat edge pixels indefinitely; 
- (cyclic) wrap (repeat or tile): loop ‚Äúaround‚Äù the image in a ‚Äútoroidal‚Äù configuration;
-  mirror: reflect pixels across the image edge
- extend: extend the signal by subtracting the mirrored version of the signal from the edge pixel value

####  Separable filtering

The idea of "Separable filtering" is to reduce the time of process by separate the filter into 2 perpendicular 1-D vectors. Normally, we will SVD to find the vectors. The time will become O(M+N) instead of O(M*N).

## Thinking in Frequency

#### Fourier Transform

Fourier transform stores the magnitude and phase at each frequency

- Magnitude encodes how much signal there is at a particular frequency
- Phase encodes spatial information
- For mathematical convenience, this is often notated in terms of complex numbers

$$
Amplitude: A =\pm \sqrt{R(\omega)^2 + I(\omega)^2}  \\
Phase : \phi = \tan^{-1} \frac{I(\omega)}{R(\omega)}\\
Euler's formula: e^{inx} = \cos(nx) +i \sin(nx)
$$

#### The Convolution Theorem

The Fourier transform of the convolution of two functions is the product of their Fourier transforms

The inverse Fourier transform of the product pf two Fourier transforms is the convolution of the two inverse Fourier transforms.

Convolution in spatial domain is equivalent to multiplication in frequency domain.

![image-20230829230305857](CS-445.assets/image-20230829230305857.png)

![image-20230829230529087](CS-445.assets/image-20230829230529087.png)![image-20230829230322853](CS-445.assets/image-20230829230322853.png)

## Color Balancing

#### Color balancing via linear adjustment

Simple idea: multiply R,G, and B values by separate constants

![image-20230909133001173](CS-445.assets/image-20230909133001173.png)

Note: better for gray picture than RGB picture

#### Global Operator

$$
L_{display} = \frac{L_{world}}{1+L_{world}}
$$

#### Point processing

we can use log function or gamma adjustment to apply the function to all the point.

## Histogram Equalization

Basic idea: reassign values so that the number of pixels with each value is more evenly distributed

Histogram: a count of how many pixels have each value
$$
h_i = \sum_j 1(p_j == 1)
$$
Cumulative histogram: count of number of pixels less than or equal to each value

Goal: Given image with pixel values $0 ‚â§ p_j ‚â§ 255, ùëó = 0. . ùëÅ$ specify function $f(ùëñ)$ that remaps pixel values, so that the new values are more broadly distributed.

1. Compute cumulative histogram: $c(i), i = 0..255$
   $$
   h(i) = \sum_j 1(p_j == i), c(i) =c(i-1) +h(i)
   $$

2. $f(i) = \alpha \cdot \frac{c(i)}{N} \cdot 255 + (1-\alpha) \cdot i$ where $i$ is the intensity of the pixels

‚Äì Blends between original image and image with equalized histogram

![image-20230909140051801](CS-445.assets/image-20230909140051801.png)
